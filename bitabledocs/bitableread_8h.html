<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>bitable: include/bitableread.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">bitable
   &#160;<span id="projectnumber">0.1</span>
   </div>
   <div id="projectbrief">Ordered immutable key value storage system.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('bitableread_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">bitableread.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Interface for reading from a bitable. Note that readable bitables are immutable and that apart from allocating/opening and closing the table, no resource allocation is directly performed.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="bitablecommon_8h_source.html">bitablecommon.h</a>&quot;</code><br />
</div>
<p><a href="bitableread_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_bitable_cursor.html">BitableCursor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aff11b300ecbc3565d1f3821d054745db"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a></td></tr>
<tr class="separator:aff11b300ecbc3565d1f3821d054745db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7416ea4c352521213e52b73fe1703d58"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="struct_bitable_cursor.html">BitableCursor</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#a7416ea4c352521213e52b73fe1703d58">BitableCursor</a></td></tr>
<tr class="separator:a7416ea4c352521213e52b73fe1703d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8cbc2a50d9968c44bee38e6eb97104b"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0">BitableFindOperation</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#ae8cbc2a50d9968c44bee38e6eb97104b">BitableFindOperation</a></td></tr>
<tr class="separator:ae8cbc2a50d9968c44bee38e6eb97104b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a8bb46095249a85b3eac8ca529a5f9ab0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0">BitableFindOperation</a> { <a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0a25a4a3a65d822956225895c1971960ad">BFO_LOWER</a> = 0, 
<a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0adce71b042e510c7533fc8c8e8ec4eb37">BFO_UPPER</a> = 1, 
<a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0a94022e9062125c04c99fcd8f53a6f784">BFO_EXACT</a> = 2
 }</td></tr>
<tr class="separator:a8bb46095249a85b3eac8ca529a5f9ab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a12994921a4dd707ec723859fe94a47d5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#a12994921a4dd707ec723859fe94a47d5">bitable_read_allocate</a> ()</td></tr>
<tr class="separator:a12994921a4dd707ec723859fe94a47d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad095a13d13430f7cc2dd61e26015aa78"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#ad095a13d13430f7cc2dd61e26015aa78">bitable_read_open</a> (<a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table, const char *path, <a class="el" href="bitablecommon_8h.html#a39fdee7ecf1bfc16f076b39c8ac4844c">BitableReadOpenFlags</a> openFlags, <a class="el" href="bitablecommon_8h.html#a4bceb5d14fadc6b6cdda00f8e3e46794">BitableComparisonFunction</a> *comparison)</td></tr>
<tr class="separator:ad095a13d13430f7cc2dd61e26015aa78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa51f86960ff7e071bedbe5bb7b048c42"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#aa51f86960ff7e071bedbe5bb7b048c42">bitable_read_close</a> (<a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table)</td></tr>
<tr class="separator:aa51f86960ff7e071bedbe5bb7b048c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca0f57bd504f480e43fa30bdce6c920"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#aeca0f57bd504f480e43fa30bdce6c920">bitable_read_free</a> (<a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table)</td></tr>
<tr class="separator:aeca0f57bd504f480e43fa30bdce6c920"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7627fefcb46b3266dbd34cd87614cd4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#a7627fefcb46b3266dbd34cd87614cd4e">bitable_readable_stats</a> (const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table, <a class="el" href="struct_bitable_stats.html">BitableStats</a> *stats)</td></tr>
<tr class="separator:a7627fefcb46b3266dbd34cd87614cd4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaefea10490447c4d612aa7b906b8994"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#aaaefea10490447c4d612aa7b906b8994">bitable_find</a> (<a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table, const <a class="el" href="struct_bitable_value.html">BitableValue</a> *searchKey, <a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0">BitableFindOperation</a> operation)</td></tr>
<tr class="separator:aaaefea10490447c4d612aa7b906b8994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f257958d3645e50a265ab9bf7255849"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#a8f257958d3645e50a265ab9bf7255849">bitable_first</a> (<a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table)</td></tr>
<tr class="separator:a8f257958d3645e50a265ab9bf7255849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af724a084b90077a7790c5c19aa4b25a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#af724a084b90077a7790c5c19aa4b25a4">bitable_last</a> (<a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table)</td></tr>
<tr class="separator:af724a084b90077a7790c5c19aa4b25a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab30e9a7318f66e4ad7d115da02a6ce98"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#ab30e9a7318f66e4ad7d115da02a6ce98">bitable_next</a> (<a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table)</td></tr>
<tr class="separator:ab30e9a7318f66e4ad7d115da02a6ce98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2867a65d6227aa2c762dff0edac0dca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#aa2867a65d6227aa2c762dff0edac0dca">bitable_previous</a> (<a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table)</td></tr>
<tr class="separator:aa2867a65d6227aa2c762dff0edac0dca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ab021edc5dab123f51e39118cd864ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#a2ab021edc5dab123f51e39118cd864ec">bitable_key</a> (const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table, <a class="el" href="struct_bitable_value.html">BitableValue</a> *key)</td></tr>
<tr class="separator:a2ab021edc5dab123f51e39118cd864ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92aaf97dee197cfeb6d040a95589aba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#ae92aaf97dee197cfeb6d040a95589aba">bitable_value</a> (const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table, <a class="el" href="struct_bitable_value.html">BitableValue</a> *value)</td></tr>
<tr class="separator:ae92aaf97dee197cfeb6d040a95589aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae56bfe524933eec7f5d4be1929591fcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#ae56bfe524933eec7f5d4be1929591fcd">bitable_key_value_pair</a> (const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table, <a class="el" href="struct_bitable_value.html">BitableValue</a> *key, <a class="el" href="struct_bitable_value.html">BitableValue</a> *value)</td></tr>
<tr class="separator:ae56bfe524933eec7f5d4be1929591fcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7843f5ae891856aa9cb0470b2724e5b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="bitableread_8h.html#a7843f5ae891856aa9cb0470b2724e5b8">bitable_indice</a> (const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *cursor, const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *table, uint64_t *indice)</td></tr>
<tr class="separator:a7843f5ae891856aa9cb0470b2724e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Interface for reading from a bitable. Note that readable bitables are immutable and that apart from allocating/opening and closing the table, no resource allocation is directly performed. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a7416ea4c352521213e52b73fe1703d58"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="struct_bitable_cursor.html">BitableCursor</a>  <a class="el" href="struct_bitable_cursor.html">BitableCursor</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A cursor - represents a position in the bitable that contains a key value pair. Cursors index into the leaf level directly (page and item within the leaf page). </p>

</div>
</div>
<a class="anchor" id="ae8cbc2a50d9968c44bee38e6eb97104b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0">BitableFindOperation</a>  <a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0">BitableFindOperation</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operations that can be used with the find function. </p>

</div>
</div>
<a class="anchor" id="aff11b300ecbc3565d1f3821d054745db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A bitable that can be read from. Allocate on the heap using bitable_read_allocate. Open an allocated one from the file system using bitable_read_open. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a class="anchor" id="a8bb46095249a85b3eac8ca529a5f9ab0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0">BitableFindOperation</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Operations that can be used with the find function. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a class="anchor" id="a8bb46095249a85b3eac8ca529a5f9ab0a25a4a3a65d822956225895c1971960ad"></a>BFO_LOWER&#160;</td><td class="fielddoc">
<p>Lower bound search - use this to find the item at the start of a range (inclusive). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8bb46095249a85b3eac8ca529a5f9ab0adce71b042e510c7533fc8c8e8ec4eb37"></a>BFO_UPPER&#160;</td><td class="fielddoc">
<p>Upper bound search - use this to find the item at the end of a range (inclusive). </p>
</td></tr>
<tr><td class="fieldname"><a class="anchor" id="a8bb46095249a85b3eac8ca529a5f9ab0a94022e9062125c04c99fcd8f53a6f784"></a>BFO_EXACT&#160;</td><td class="fielddoc">
<p>Exact match search - will return an error if the find operation doesn't result in an exact match. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="aaaefea10490447c4d612aa7b906b8994"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_bitable_value.html">BitableValue</a> *&#160;</td>
          <td class="paramname"><em>searchKey</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bitableread_8h.html#a8bb46095249a85b3eac8ca529a5f9ab0">BitableFindOperation</a>&#160;</td>
          <td class="paramname"><em>operation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a key and find operation, find a matching position in the bitable and populate the cursor with it. This method is thread-safe on an open table (but the table must be open for the duration of the call), as it does not modify the bitable. BFO_EXACT searches will only find exact key matches, BFO_LOWER will find the lower inclusive bound of a range. BFO_UPPER will find the upper inclusive bound of a range search. Note that this function does not allocate memory from the heap, but it may cause memory to be demand paged (memory mapped file). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The cursor that will be populated with the find position. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to find the key in. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">searchKey</td><td>The key to search for. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">operation</td><td>The operation to use for searching. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_KEY_NOT_FOUND is the operation is BFO_EXACT and the key doesn't exist in the bitable. BR_END_OF_SEQUENCE if the operation is an upper/lower bound and the bound is outside the bitable range. </dd></dl>

</div>
</div>
<a class="anchor" id="a8f257958d3645e50a265ab9bf7255849"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_first </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the cursor with the first position (beginning) of the bitable. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The cursor that will be populated with the first position. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to get the position of. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_END_OF_SEQUENCE if the bitable is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="a7843f5ae891856aa9cb0470b2724e5b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_indice </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t *&#160;</td>
          <td class="paramname"><em>indice</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the indice (0 based) at a particular cursor position. The indice number of key value pairs before the one at the cursor. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cursor</td><td>The cursor position that will be read from. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to read from. Should not be null. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">indice</td><td>The indice to read out. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_INVALID_CURSOR_LOCATION if the cursor position isn't valid. </dd></dl>

</div>
</div>
<a class="anchor" id="a2ab021edc5dab123f51e39118cd864ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_key </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bitable_value.html">BitableValue</a> *&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the key at a particular cursor position from the bitable. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cursor</td><td>The cursor position that will be read from. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to read from. Should not be null. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The key to read out. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_INVALID_CURSOR_LOCATION if the cursor position isn't valid. </dd></dl>

</div>
</div>
<a class="anchor" id="ae56bfe524933eec7f5d4be1929591fcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_key_value_pair </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bitable_value.html">BitableValue</a> *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bitable_value.html">BitableValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read both the key and value value at a particular cursor position from the bitable. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cursor</td><td>The cursor position that will be read from. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to read from. Should not be null. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">key</td><td>The key to read out. Should not be null. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The key value read out. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_INVALID_CURSOR_LOCATION if the cursor position isn't valid. </dd></dl>

</div>
</div>
<a class="anchor" id="af724a084b90077a7790c5c19aa4b25a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_last </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the cursor with the last position (at the end) of the bitable. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">cursor</td><td>The cursor that will be populated with the last position. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to get the position of. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_END_OF_SEQUENCE if the bitable is empty. </dd></dl>

</div>
</div>
<a class="anchor" id="ab30e9a7318f66e4ad7d115da02a6ce98"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the cursor with the next position from its current value. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>The cursor that will be incremented to the next position. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to perform the operation with. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is fdsuccessful. BR_END_OF_SEQUENCE if the next position is beyond the end of the sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="aa2867a65d6227aa2c762dff0edac0dca"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_previous </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the cursor with the previous position from its current value. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in,out]</td><td class="paramname">cursor</td><td>The cursor that will be decremented to the previous position. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to perform the operation with. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_END_OF_SEQUENCE if the next position is beyond the end of the sequence. </dd></dl>

</div>
</div>
<a class="anchor" id="a12994921a4dd707ec723859fe94a47d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a>* bitable_read_allocate </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocate a zeroed readable bitable, to be used with bitable_read_open (can be re-used multiple times, when a table is closed). </p><dl class="section return"><dt>Returns</dt><dd>The allocated readable bitable. </dd></dl>

</div>
</div>
<a class="anchor" id="aa51f86960ff7e071bedbe5bb7b048c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_read_close </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the file handles (etc) associated with a previously opened readable bitable. Note, this operation can be called on an already closed table (idempotence). This does not free the memory associated with the BitableReadable, so it can be re-used. Closing/opening with regards to the BitableReadable instance are not thread safe operations so they should only be done exclusively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The readable bitable to close. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the table could be successfully closed. </dd></dl>

</div>
</div>
<a class="anchor" id="aeca0f57bd504f480e43fa30bdce6c920"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> void bitable_read_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Close the file handles (etc) associated with a previously opened readable bitable and frees the memory associated with it. Note, this operation can be called on an already closed table to de-allocate it. Closing/opening with regards to the BitableReadable instance are not thread safe operations so they should only be done exclusively. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">table</td><td>The readable bitable to close. Should not be null. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad095a13d13430f7cc2dd61e26015aa78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_read_open </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bitablecommon_8h.html#a39fdee7ecf1bfc16f076b39c8ac4844c">BitableReadOpenFlags</a>&#160;</td>
          <td class="paramname"><em>openFlags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="bitablecommon_8h.html#a4bceb5d14fadc6b6cdda00f8e3e46794">BitableComparisonFunction</a> *&#160;</td>
          <td class="paramname"><em>comparison</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a bitable from the file system for reading. Apart from bitable_read_allocate, this is the only read function that allocates memory directly (memory may be demand paged for reading from the memory mapped files). It is safe to open the same path multiple times with different BitableReadable instances, even in different processes. You should not try and re-use the same BitableReadable instance without closing it. Closing/opening with regards to the BitableReadable instance are not thread safe operations so they should only be done exclusively. Memory mapped within bitable_read_open should be protected to be read only. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">table</td><td>The previously allocated readable bitable to open into. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">path</td><td>The path to the bitable to open, in UTF8 encoding (even on Windows extended charactesr are supported). Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">openFlags</td><td>The flags to use for opening the bitable - note reading hints will be applied to leaf and large value files only, </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">comparison</td><td>A comparison function that will be used to compare keys for searching. This should match the sort order when the keys were appended. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the table could be successfully opened for reading, an error code otherwise (BR_ALREADY_OPEN, BR_FILE_OPERATION_FAILED, BR_FILE_TOO_SMALL, BR_HEADER_CORRUPT, BR_FILE_OPEN_FAILED, BR_FILE_TOO_LARGE). </dd></dl>

</div>
</div>
<a class="anchor" id="a7627fefcb46b3266dbd34cd87614cd4e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_readable_stats </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bitable_stats.html">BitableStats</a> *&#160;</td>
          <td class="paramname"><em>stats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the statistics associated with a particular bitable (including the number of items, depth, page size, key and value alignments etc). This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to get the stats from. Should not be null. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">stats</td><td>The stats from the table. Should not be null. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the stats could successfully be retrieved. </dd></dl>

</div>
</div>
<a class="anchor" id="ae92aaf97dee197cfeb6d040a95589aba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="bitablecommon_8h.html#a438737f7989a89c5b25fd799766eab52">BITABLE_API</a> <a class="el" href="bitablecommon_8h.html#a1afc578b2f3f472486d93bf036c1d9a5">BitableResult</a> bitable_value </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="struct_bitable_cursor.html">BitableCursor</a> *&#160;</td>
          <td class="paramname"><em>cursor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="bitableread_8h.html#aff11b300ecbc3565d1f3821d054745db">BitableReadable</a> *&#160;</td>
          <td class="paramname"><em>table</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_bitable_value.html">BitableValue</a> *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read the value at a particular cursor position from the bitable. This method is thread-safe on an open table (but the table must be open for the duration of the call). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">cursor</td><td>The cursor position that will be read from. Should not be null. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">table</td><td>The open readable bitable to read from. Should not be null. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">value</td><td>The key value read out. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BR_SUCCESS if the operation is successful. BR_INVALID_CURSOR_LOCATION if the cursor position isn't valid. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="bitableread_8h.html">bitableread.h</a></li>
    <li class="footer">Generated on Thu Jan 1 2015 19:00:42 for bitable by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
